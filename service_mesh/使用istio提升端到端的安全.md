传统的网络安全方法无法解决部署在动态生产环境中的分布式应用程序的安全威胁。今天我们将介绍Istio Auth如何帮助企业将他们的安全形态从边缘防护转变为始终如一地保护应用程序内的所有服务间通信。借助Istio Auth开发和运维人员可以使用敏感数据来保护服务，防止未经授权的内部人员访问，并且在无需更改应用程序代码即可达成目标！

Istio Auth是更广泛的Istio平台的安全组件。它结合了在Google生产环境中数百万微服务节点保护所获的知识。

## 背景
现代应用程序体系结构越来越多地基于在云平台上动态部署和扩展的共享服务。 传统的网络边缘安全（如防火墙）过于粗放，允许从非预期的客户端访问。 一个安全风险的例子是可以从另一个客户端重放的被盗认证令牌。 对于那些关注内部威胁的敏感数据的公司而言，这是一个主要风险。 其他网络安全方法（如IP白名单）必须静态定义，难以大规模管理，不适合动态生产环境。

因此，安全管理员需要一个工具，使他们能够始终如一地保持不同生产环境下服务之间的所有通信。

## 解决方案：强服务标识和认证

Google多年来一直在开发便于在生产环境中统一保护数百万个微服务端点，防止外部攻击和内部威胁的体系结构和技术。 关键的安全原则包括：信任端点而不是网络，基于服务标识和服务级授权的强互认证。 Istio Auth基于相同的原则。

Istio Auth版本的0.1版本在Kubernetes上运行，并提供以下功能：
服务之间的强标识判定
基于访问服务（及其数据）身份限制的访问控制
传输中的数据自动加密
按比例的密钥和证书管理

Istio Auth基于mTLS和X.509等行业标准。 此外，Google正在积极推动一个名为SPIFFE的开放的，社区驱动的服务安全框架。 随着SPIFFE规范的成熟，我们打算让Istio Auth成为SPIFFE的一个实现案例。

下图提供了Kubernetes上Istio Auth服务认证体系结构的描述：

上图说明了三个关键的安全特性：

## 强身份标识

Istio Auth使用Kubernetes服务帐户来确定服务的运行方式。身份用于建立信任并定义服务级别访问策略。身份在服务部署时分配，并在X.509证书的SAN（主题备用名称）字段中进行编码。 使用服务帐户作为身份有以下优点：

管理员可以使用Kubernetes 1.6中引入的RBAC功能来配置谁可以访问服务帐户
灵活识别人类用户，服务或一组服务
服务标识的动态放置和自动扩展工作负载的稳定性

## 通信安全
服务到服务通信是通过高性能的客户端和服务器端Envoy代理隧道传输的。 代理之间的通信使用mTLS来保证。 使用mTLS的好处是，服务标识不能够为可从其他来源窃取或重放的不记名令牌所代表。 Istio Auth还介绍了安全命名的概念，以防止服务器欺骗攻击 - 客户端代理验证已验证的服务器的服务帐户是否允许运行指定的服务


## 密钥管理和分配

Istio Auth提供了每个集群CA（证书颁发机构）和自动化密钥和证书管理。在这种情况下，Istio Auth：

为每个服务帐户生成密钥和证书对。
使用Kubernetes Secrets将密钥和证书分发到适当的pod。
定期轮换密钥和证书。
必要时撤销特定的密钥和证书对。

下图解释了Kubernetes上的端到端Istio Auth身份验证工作流程：

Istio Auth是更广泛的容器安全故事的一部分。 红帽公司是Kubernetes开发的合作伙伴，已经确定了10个容器安全层。 Istio和Istio Auth涉及两个层次：“网络隔离”和“API和服务端点管理”。 随着集群联盟在Kubernetes和其他平台上的发展，我们的目标是让Istio保护跨越多个联合集群的服务通信。

## Istio Auth的优点

纵深防御：当与Kubernetes（或基础设施）网络策略结合使用时，用户可以获得更高的置信度，因为它知道pod-to-pod或服务到服务通信在网络层和应用层都是安全的。

默认安全：与Istio的代理和集中策略引擎一起使用时，Istio Auth可以在部署过程中进行配置，只需少量的应用程序修改或者不更改。 因此，管理员和运维可以确保服务通信在默认情况下得到保护，并且可以通过不同的协议和运行时一致地执行这些策略。

强服务认证：Istio Auth使用mTLS保障服务通信，以确保服务身份不被可能从其他来源窃取或重放的不记名令牌表示。 这确保了敏感数据的服务只能通过强认证和授权的客户端访问

## 加入我们的旅程

istio Auth是提供全面功能的第一步，可以保护敏感数据免受外部攻击和内部威胁。 虽然初始版本运行在Kubernetes上，但是我们的目标是使Istio Auth能够在不同的生产环境中保护服务。 我们鼓励社区的加入，在不同的应用程序栈和运行时平台上提供强大的服务安全，使其无处不在。

